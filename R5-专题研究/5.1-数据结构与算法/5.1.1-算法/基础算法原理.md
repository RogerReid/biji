# 基础
## 位运算
### lowbits原理
- **作用** 找到某数n的最后一位二进制1。
- **(x  & - x)** 返回的只有最后一位是1，其他位都是0。 
0 - 原码 = 补码
所以  - 源码 = ~ 原码 + 1   （~取反标志）
( -x = ~x + 1)

### 输出n的每一位二进制数
- 与上1就是看二进制的最后一位是什么
```c++
int main()
{
	int n;
	cin >> n;
	for(int k = 3; k >=0; k --)
	{
		
		cout << (n >> k & 1) << endl;
		
	}
}
```

## 离散化
> 个人理解：好像相当于哈希映射  

**为什么要用离散化** ：因为有时候数组很大，但是我们用不到那么多，我们只用到其中的一部分，我们可以将用到的离散化，到时候只用离散化后的索引的数据就行了。
① 可能有重复元素，需要**去重**
② 如何算出a[n]离散化后的值
[[C-C++#unique函数，容器元素去重 || 去掉重复元素函数的使用方法]]
- 如何去重
```c++
vectot<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end(), alls.end()); // 去掉重复元素
```
## 二维前缀和--求子矩阵的和

[参考博客](https://www.acwing.com/solution/content/3797/)

>个人的理解：
>
>第一个公式记法：就是 i 和 j 各减一次 1相加，然后减去 i和j都减一次1的，再加上 a【i】【j】最后会单独加一个格。
>
>第二个公式记法：没有单独加一个格的。

![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C.png)

