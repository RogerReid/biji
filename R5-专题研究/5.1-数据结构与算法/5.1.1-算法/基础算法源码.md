# 基础算法
## 一，十大排序
### 1，冒泡排序
```c++
#include <iostream>
using namespace std;

int main()
{
	// 冒泡排序
	int array[10]={10,9,8,7,6,5,4,3,2,1};
	
	int length = sizeof(array)/sizeof(int);
	for(int i=0;i<length;++i)
	{
		for(int j=0;j<length-1-i;++j)
		{
			if(array[j]>array[j+1])
			{
				// 交换位置
				array[j] = array[j]^array[j+1];
				array[j+1] = array[j]^array[j+1];
				array[j] = array[j]^array[j+1]; 
			}
		}
	}
	
	// 打印数组
	for(int i=0;i<length;++i)
	{
		cout << array[i] << " "; 
	 } 
	return 0;
}
```

### 2，选择排序
```c++
#include <iostream>
using namespace std;

int main()
{
	// 选择排序
	int array[10]={10,9,8,7,6,5,4,3,2,1};
	int length = sizeof(array)/sizeof(int);
	for(int i=0;i<length-1;++i)
	{
		
		for(int j=i+1;j<length;++j)
		{
			if(array[j]<array[i])
			{
				array[j] = array[j]^array[i];
				array[i] = array[j]^array[i];
				array[j] = array[j]^array[i];
			}
		}
	}
	// 打印数组
	for(int i=0;i<length;++i)
	{
		cout << array[i] << " ";
	} 
	return 0;
	
} 
```

### 3，快速排序
[[技巧#1，将除以2，换成移位运算| 为什么要使用 1+ r >> 1]]
[[语法#2.1 加减法运算符（+-) 和 移位运算符 (<< >>) | 加法和移位优先级]]
```c++
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}

```

### 3，归并排序
```c++
void merge_sort(int q[], int l, int r)
{
	if (l >= r)	return;
	
	int mid = l + r >> 1;
	merge_sort(q, l, mid), merge_sort(q, mid + 1, r);
	
	int k = 0, i = l, j  = mid + 1;
	while (i <= mid && j <= r)
		if (q[i] <= q[j])	tmp[k ++ ] = q[ i ++ ];
		else	tmp[k ++ ] = q[ j ++ ];
	
	while ( i <= mid)	tmp[k ++] = q[i ++ ];
	while ( j <= r)		tmp[k ++ ] = q[ j ++ ];
	
	for (int i = l, j = 0; i <= r; i ++ , j ++ )	q[i] = tmp[j];
}
```



## 二，查找
### 1，整数二分查找
```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
// 这一个会有边界问题，所以Mid = l + r + 1； 否则会涉及到边界问题。
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}

作者：yxc
链接：https://www.acwing.com/blog/content/277/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```