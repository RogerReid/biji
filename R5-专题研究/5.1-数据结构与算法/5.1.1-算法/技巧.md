# 一，交换整型数的三种方法
[[交换整型数]]
## 1，设置中间变量
```C
void swap(int *p1,int *p2) 
{ int temp;
 
  temp=*p1;
   
  *p1=*p2;
   
  *p2=temp;
}
```

## 2，加减法
**加减法的弊端**：容易产生溢出，如果两个数都特别大的话，那么就容易溢出。
```C
#include <stdio.h>
int main()
{
	int a=1, b=2;
	
	a = a+b;
	
	b = a-b;
	
	a = a-b;
	
	printf("a=%d,b=%d", a,b);  // a=2, b=1;
}
```

## 3，用异或交换
该方法不会出现溢出的问题。
```C
int main()

{

    int a=1, b=2;

    a = a^b;

    b = a^b;

    a = a^b;

    printf("a=%d, b=%d", a, b);  // a=2,b=1;

}
```

> 解释
> 本身和本身异或是0
> 任何数 和 0 异或 都等于任何数
# 二，实现四舍五入
输出%d的时候如果是Int的会直接舍去小数，如果想要四舍五入就要这样
**先转化成带一个小数点再整除，最后加0.5** （如果后面小数超过0.5就会进位，如果没有就会舍去。）
![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5.png)

# 三，算出多位数的每一位
/10 -> 代表着舍弃最后一位。
%10 -> 代表着只保留最后一位。
/1000 -> 代表着只取4位数的第一位。（其他位同理）。
```C++
#include <iostream>
using namespace std;

int main()
{
	// 算出一个多位数每一位的数 
	int number;
	int ge;
	int shi;
	int bai;
	int qian;
	cout << "请输入数字："<< " "; 
	cin >> number;
	ge = number%10;
	shi = number/10%10;
	bai = number /100%10;
	qian = number/1000;
	cout << ge << endl;  
	cout << shi << endl;
	cout << bai << endl;
	cout << qian << endl;
	
	 
}
```

# 四，数字和英文小写字母之间转化
- 数字和英文小写字母差97
- 0 +97 就是a
```C++
int i=0;
char x = i+97;
cout << x << endl; // x=a;
```

# 五，提高速度
## 1，将除以2，换成移位运算
原始数据N
- 1，**非负数时 r >> 1  ==  r/2;  向下取整** 
- 2，负数且为偶数时候，>> 1 和 /2 一样
- 3，负数且为技术时，>>1：向下取整，/2：向上取整。  -5>>1 == -3,  -5/2 == (int)(-2.5)=-2

## 2，用异或交换两个数
[[技巧#3，用异或交换 | 为什么可以用异或交换两个数]]
```c++
 // 用异或交换两个数
	int a = 10, b = 20;
	a ^= b ^= a ^= b;
	
	cout << "a=" << a << endl;  // a=20
	cout << "b=" << b << endl;  // b=10
```

## 3，提高 cin 的读取速度
```c++
int main()
{   // 数据输入大于100万一般就用scanf了1000000
	ios::sync_with_stdio(false);  // 缺点是不能用scanf了，但是优化过后也没有scanf快

}

```
# 六，代码风格
- 1，实现数据中间空格，数据最后换行     " \n"[限制条件]
```c++
for(int i = 0; i < 10; i ++ )
		printf("%d%c", i, " \n"[i==9]);
// 输出 0 1 2 3 4 5 6 7 8 9 \n（换行）
```
其实就是个字符常量，后面的[ ]是它的索引。

# 七，将字符型数字转化为整数值
直接将字符 - '0'，就会得到这个字符型数字的整数值。**解释：** 其实就是ASCII相减，然后得到一个相对值
```c++
cout << '9' - '0' << endl;   // 整数型int 9
```

# 八，计算重复子串-Rabin Karp算法
拉宾卡普算法
[参考博客1](https://coolcao.com/2020/08/20/rabin-karp/)
[参考博客2](https://labuladong.github.io/algo/2/20/28/)

# 九，模运算的运算法则
>X % Q == (X + Q) % Q 
>
  (X + Y) % Q == (X % Q + Y % Q) % Q

# 判断年是不是闰年
```c++
bool isLeap(int y)

{

    return ( y%4==0 & y%100 !=0) || (y%400 == 0);
    // 如果是一般年份能被4整除且能被100整除的就是闰年
    // 如果是世纪年（2000）能被400整除的就是闰年
    // 如果是闰年，必定能满足一条

}
```

# 从一个数字提取前几位或者后几位
- **提取前几位** 
	- 用 **/** 1后面有几个0就是去掉数后面的几位。
	- 例如 2022 / 100 = 20  1 后面有两个0就是去掉最后面的两个。
- **提取后几位** 
	- 用 **%** 1后面有几个0就是保留最后的几位
