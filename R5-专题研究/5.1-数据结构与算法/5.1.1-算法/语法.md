# 1，static_cast 强制类型转换.
用于整型 浮点型、字符型之间的转换。
```c++
int a;
static_cast<double> a;  // 强制转换成double

```

# 2，优先级问题
### 2.1 加减法运算符（+-) 和 移位运算符 (<< >>)
加法运算符的优先级大，有加减和移位，先算加减。

# 3，inline关键字
## 作用
解决频繁调用的小函数大量的消耗栈空间（放置程序的局部数据），在系统中，栈空间是有限，大量使用会导致栈空间不足（例如函数死循环调用）
## 使用限制
函数内只有简单的代码，没有复杂的控制语句数）

# 4，万能头文件
```c++
#include <bits/stdc++.h>
```

# 5，单引号和双引号的区别
单引号代表的是字符，双引号代表的是个字符串。
- 错误示范
```c++
string s;
s = "abcda";
for(char c:s)
{
	if ( c == "a") printf("找到");  // 这里如果用双引号就会报错。
}
```
这里a用双引号括起来会报错，因为这里编译器会认为这是两个字符串之间的比较，但是前面的c是一个字符，所以会报错。
- 正确
```c++
string s;
s = "abcda";
for( char c:s)
{
	if ( c == 'a') printf("找到");  // 这是正确的用法
}
```

# 6，整数溢出
- **溢出** 
	- 只有有符号数才会发生溢出，有符号数最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出。
- **回绕** 
	- 无符号数 0 - 1会变成最大的数，例如1字节的无符号数会变成255，而255+1就会变成0。**结果超过了最大值的数会被表示为该数对最大值+1取模。** 
- **截断**
	- 将一个较大宽度的数存入一个宽度小的操作数中，高位发生截断。
- 感觉溢出和回绕是一个类型，只是溢出可以从负数回绕到正数。
- 这个有符号的溢出，正数溢出了不一定是负数，因为c语言规定对于有符号的溢出是“**undefined behavior**”，这是就爱是多少是多少，算出来是多少就是多少，没有规定。是个随机值。
# 7，int和long long的位数
int 最高位是一个开头是2的十位数（长度）
long long 最高是一个以9开头的十九位数（长度）
>int和long都是用32位来存储最大值和最小值分别为2147483647（109）， -2147483648；
>
>long long 是用64位来存储最大值和最小值分别为9223372036854775807（1018），-9223372036854775808；
>
>float的最大值和最小值分别为3.40282e+038（10^38），1.17549e-038（10-38）；   它的sizeof值为4.
>
>double的最大值和最小值分别为1.79769e+308（10^308），2.22507e-308（10-308）。 它的sizeof值为8.

# 8，位运算符号
**在计算机中，计算机存储负数的时候，是存取该负数的正数的补码（~源码 + 1）**
- 逻辑运算符
	- & 位 与
	- ^  位 异或
	- |  位 或
	- ~ 位 取反
- 移位运算符
	- << 左移
	- >> 右移

# 9，字符常数（char/' ')和字符串常数(string/ " ")

- **char变量**:只能保存一个字符，初始化的时候只能是用 **' '** (单引号）
- 存储方式不同
	- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2.png)
- 存储内容不同
	- 在内部存储的是每个字符的ASCII但是字符串最后会有个null的ASCII,也就是null终止符。
	- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B22.png)
