# 一，二叉排序树
### 1，特性
- 可能是一个空树。
- 左子树<根节点，右子树>根节点。
- 左右子树也分别为二叉排序树。
### 2，性能
- 二叉排序树查找-时间复杂度0(log(2)n)

# 二，平衡二叉树（AVL）
## 1，性质
-  1，在二叉查找树上加上左右子树的**深度最多相差1。** 
-  2，每差入一个节点，先判断插入后的二叉树是否平衡，如果不平衡要旋转来使平衡
## 2，平衡因子
- 左子树高度减去右子树的高度的值或者右子树高度减去左子树高度的值。显然 -1 <=bf <= 1
- 当平衡因子大于1的时候就要对二叉树进行旋转。
## 3，旋转
 [平衡二叉树的旋转参考博客](https://blog.csdn.net/jyy305/article/details/70949010)
> 没什么不好理解的，如果左边高的话，那自然希望它降低点，右旋就是把左节点拉上来，当前节点下去，左节点的右子树，变成当前节点的右子树。左子树减一右子树加一，这就平衡了，但是有个问题，就是右子树过去了，可能之前不平衡就是因为左子树的右子树产生的，如果直接过去了，还是不平衡，所以需要左子树的右子树左旋，使得不平衡是因为左子树的左子树产生的。
- 左左（在较高左子树的左侧插入）-> 右旋
	- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC1.png)
	- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E5%B7%A6%E5%B7%A62.png)

- 右右（在较高右子树的右侧插入）-> 左旋
	- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC2.png)
	- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E5%8F%B3%E5%8F%B32.png)

- 左右（在较高左子树的右侧插入）-> 先左旋后右旋
	- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC3.png)
	- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E5%B7%A6%E6%9C%892.png)

- 右左（在较高右子树的左侧插入）-> 先右旋后左旋
	- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC4.png)
	- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E5%8F%B3%E5%B7%A62.png)
**判断该如何旋转：** 
- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/202211071800062.png)
- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/202211071802099.png)




# 三，哈希表
## 1，解决哈希冲突
-  **1.1 开放定址法** （开放mod个地址，**如果冲突的是最后一个地址，就从第一个地址依次探查**） 
	-  **1.1.1 线性探测法：** 先找到对应的地址d，如果该地址已经被占用了（发生冲突），就依次探查d+1,d+2........。**（也可以在前面探查）**
	- **1.1.2 平方探测法：** 就是下次探查d^2^和线性差不多只是下次探查的不一样。
	- **1.1.3 双散列：** 该地址占用了，就用另一个哈希函数来计算新的地址。
- **1.2 拉链法**
	- 在一个地址创建一个单链表，每次添加就在该链上添加。

# 四，图
## 1，定义和术语
- **度：** 和顶点相关联的边。
- **环：** 第一个顶点和最后一个顶点相同的路径称为**环**或**回路**。就是一个顶点走了一圈又回来了，注意有向图的方向问题。
- **连通图：** 每个顶点之间都能通过边相互连通，并不需要完全图，就是有路径能连通就行。3
- **强连通图：** **有向图**中若任意两个顶点 Vi 和 Vj，满足从 Vi 到 Vj 以及从 Vj 到 Vi 都连通，也就是都含有至少一条通路，则称此有向图为强连通图。（一定有环）有向图中任意两个顶点都能互相到达。
	- 如何判断有向图是否为强连通图
		先随机找一个节点S，从这个节点深度遍历，如果能遍历图的所有节点，将图的方向反转，然后继续从S进行深度遍历，如果还能遍历所有节点，那么这个有向图是个强连通图。
- **强连通分量：** 若有向图本身不是强连通图，但其包含的最大连通子图具有强连通图的性质，则称该子图为强连通分量。
- **连通分量**
	- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png)
- **生成树：** 去掉几个重复的边，剩下的保持边最少还能连通。
## 2，图的储存结构
### 2.1 邻接矩阵
- 优势：容易判断任意两个顶尖之间是否有边（或弧）相连，并容易求得各个顶点的度。
### 2.2 邻接表iij
### 2.3 十字链表
### 2.4 邻接多重表
## 3，顶点，弧，边之间的关系
- 3.1 完全图边数
	-  无向完全图边数：n*(n-1)/2
	-  有向完全图边数：n*(n-1)   (无向完全图变数的二倍)