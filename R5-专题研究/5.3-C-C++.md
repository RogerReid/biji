## 一，全局数组和局部数组的区别
- 全局数组（定义数组再main函数外面）会自动将数组初始化为0。
```c++
#include <iostream>
#include <bits/stdc++.h>
using namespace std;

int a[26];
int main()
{	
	int length = sizeof(a)/sizeof(int);
	for(int i=0;i<length;++i)
	{
		cout << a[i] << " ";
	}
	// 0 0 0 0 0 0
}
```
- 局部数组会随机分配数
```c++
#include <iostream>
#include <bits/stdc++.h>
using namespace std;


int main()
{	int a[26];
	int length = sizeof(a)/sizeof(int);
	for(int i=0;i<length;++i)
	{
		cout << a[i] << " ";
	}
	// 8 0 4254401 0 4253392 0 34 0 14488416 0 1 0 -1 -1 4253493 0 1 0 4254425 0 0 0
}
```

## 二，vector
- 一种动态数组 他会自动给Int型的初始化为0，不像c语言的局部数组一样随机分配数字。
- 常用初始化方法，
- ![](https://tuceng-1312762148.cos.ap-nanjing.myqcloud.com/Obsidian/202211061852805.png)

## 三，函数的传址和传值
### 1，传值
就是函数将实参的值copy给形参。接下来我们看一个案例。
```C
void swap(int a, int b)
{
	int temp;
	temp = a;
	a = b;
	b = temp;
}

int main()
{
	int test1=1, test2=2;
	swap(test1, test2);
	printf("test1=%d,test2=%d", test1, test2); // test1=1, test2=2 
}
```
我们看这里使用了交换函数之后test1和test2的值并没有交换，这是为什么呢？其实这就是因为形参只是copy的实参的值，函数确实把实参的数交换了，但是函数执行完之后形参都释放了，并不会影响实参。


### 2，传址
就是将实参的地址传给形参，对形参的地址操作时侯会影响实参。我们来看一个案例。
```C
void swap(int* a, int* b)
{
	int temp;
	// 这里都是操作的地址
	temp = *a;
	*a = *b;
	*b = temp; 	
}

int main()
{
	int test_1=1, test_2=2;
	// 因为函数是对地址进行操作，所有要进行取地址&
	swap(&test_1, &test_2);
	printf("test_1=%d, test_2=%d",test_1,test_2);  // test_1=2,test_2=1;
}

```
这里我们看到经过交换函数后，这里的两个数交换了，因为这里是对实参的地址进行的操作。

# 四，函数使用
## 1，memset初始化数组
- 头文件 #include<string.h>
- 语法
	- memset(数组名,初始化数,sizeof(数组名))

# 五，内存分配
[参考博客](https://www.cnblogs.com/wanghuaijun/p/6509016.html)
## 1，存储时
代码区、数据区、和未初始化数据区 3个部分
- **代码区**
	- 存放CPU执行的机器指令（可共享、只读）
	- 规划了局部变量的相关信息
- **全局初始化数据区/静态数据区**
	- 包含了在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）
	- 例如，一个不在任何函数内的声明（全局数据）
